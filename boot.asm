;Created by CyberCraft Studio in 18.08.2023
[bits 16];кажемо що пишемо код для 16 бітної системи
[org 0x7c00]; завантажувальний сектор для біосу, який розуіє, що за цією адресою знаходиться цей файл. 
;у BIOS та UEFI зазвичай саме цей сектор використовує для завантаження бутлоадера (цього файлу), але можна й інший, якщо BIOS або UEFI може розрізнити інший сектор

start:;головна секція - початкова точка виконання програми. без неї - код працювати не буде
    xor ax, ax; робить ax зі значенням "0"
    mov ds, ax; копіює значення з реєстру ax в реєстр ds, а отже так як значення ax дорівнює 0, то і ds також дорівнює 0
    mov es, ax; копіює значення з реєстру ax в реєстр es, es дорівнює 0

    mov si, hello; завантаження вказівника si із мітки hello, яка містить початкову адресу рядка для виводу
    call print_string; виклик функції print_string

    mov ah, 00h; встановлює значення регістру ah в 00h, що означає налаштуванню певної послуги біос для подальшого виконання.
	;У цьому конкретному контексті, коли відбувається очікування введення клавіші, встановлення ah в 00h вказує на чекання будь-якої клавіші від користувача. 
	;Тобто, це операція "очікування вводу".
    int 16h  ; Очікування введення клавіші

input_loop: ;опис функції input_loop
    mov ah, 0       ; Читання з клавіатури без відображення на екрані
    int 16h          ; Виклик послуги BIOS для введення з клавіатури

    cmp al, 0x0D    ; Перевірка, чи введено код клавіші Enter
    je new_line     ; Якщо так, перехід на новий рядок

    mov bl, al      ; Завантаження коду символу в регістр bl
    call print_char ; Виклик функції виведення символу на екран
    jmp input_loop  ; Повторний вхід в цикл для вводу тексту

new_line: ;опис функції new_line
    call print_new_line ; Виведення символу нового рядка
    mov bl, 0x0D    ; Виведення символу каретки
    call print_char; виклик функції print_char
    mov bl, 0x0A    ; Виведення символу нового рядка
    call print_char; виклик функції print_char
    jmp input_loop ;моментальний перехід до input_loop



print_string: ;опис  функції print_string
    mov ah, 0x0E; це інструкція, яка завантажує значення 0x0E (14 у десятковій системі числення) у регістр ah. 
	;У більшості випадків ця команда використовується для підготовки регістрів перед викликом преривань

.repeat_next_char: ;опис локальної фунції repeat_next_char , тобто в інших файлах не можна оголошувати (локальна функція описується завдяки крапки перед описом функції)
    lodsb ;lodsb - це команда в, яка використовується для завантаження байту з пам'яті, адреса якого знаходиться в регістрі si, у регістр al.
	;Після завантаження, регістр si автоматично збільшується на 1 або 2 (залежно від режиму адресації).
	;Загалом, lodsb використовується для зручного та ефективного обходу байтів у пам'яті під час обробки рядків або масивів даних.
	
    cmp al, 0; перевірка регістру al з нулем . Якщо конкретніше, то виконується перевірка, чи байт знаходиться у регістрі al та має значення нуль 
	;ця перевірка здійснюється, щоб дізнатися, чи підмножина байтів у пам'яті (наприклад, символи рядка) закінчилася байтом нуль.
    je .done_print; якщо перевірка має істину (значення true) перехід до функції done_print
    int 0x10 ;увімкнення відео режиму для відображення тексту, яке ввели
    jmp .repeat_next_char ;повторити запуск функції

.done_print:;опис локальної функції done_print , тобто в інших файлах не можна оголошувати
    ret ;завершення виконання функції та повертання до того місця де було оголошення, наприклад в функції repeat_next_char перевірка є 
	;істиною - продовжується виконання коду і перехід до рядку int 0x10

print_char: ;опис функції print_char
    mov ah, 0x0E; це інструкція, яка завантажує значення 0x0E (14 у десятковій системі числення) у регістр ah. У більшості випадків ця команда використовується 
	;для підготовки регістрів перед викликом преривань
    mov al, bl  ; Завантаження коду символу для виведення
    int 0x10;увімкнення відеорежиму в біос
    ret; завершення виконання функції

print_new_line:
    mov ah, 0x0E  ;це інструкція, яка завантажує значення 0x0E (14 у десятковій системі числення) у регістр ah. У більшості випадків ця команда використовується для підготовки 
	;регістрів перед викликом преривань
    mov al, 0x0A  ; Виведення символу нового рядка
    int 0x10;увімкнення відеорежиму в біос
    ret; завершення виконання функції

move_cursor_left:
    mov ah, 02h   ; 02h у регістрі ah вказує на те, що буде виконано послугу біосу переміщення курсора.
    mov bh, 0     ; Номер сторінки
    dec dl        ; Зменшує значення регістру dl на 1 (dl-1)
    int 10h       ; увімкнення відеорежиму
    ret			  ; завершення виконання функції

hello db 'CyberOS terminal edition version 0.1',0x0A, 0x0D, 0;hello - типу змінна, але в ассемблері це мітка db - define bytes і вказує на те, що після цього будуть 
;визначатися послідовності байтів.
;а після цього встановлюються два байти 0x0A та 0x0D, які представляють символ нового рядка 0x0A('\n') та символ каретки 0x0D ('\r')."0" (нульовий байт) вказує на завершення 
;рядка (null-terminated string) у стилі C

times 510 - ($-$$) db 0x00;Ця частина використовується щоб заповнити вільний простір цього файлу до 512 байт так як завантажувальний сектор повинен мати розмір 512 байт.
;times вказує на те, що ми будемо використовувати цю конструкцію для певної кількості разів
;510 - це максимальна довжина завантажувального сектора, який може містити 512 байт
;($-$$) - це вираз, який представляє поточну адресу ($) мінус адресу початку завантажувального сектора($$).
;db 0x00 - заповнення символу "0" (0х00) для того щоб заповнити всю іншу частину цього файлу до 512 байт
dw 0xAA55 ;вказує на додавання двобайтового значення в завантажувальний сектор. Це останні два байти в завантажувальному секторі і представляють собою сигнатуру, яка вказує на те, 
;що даний сектор є правильним завантажувальним сектором для BIOS. Коли комп'ютер завантажується, BIOS перевіряє цю сигнатуру, щоб визначити, чи сектор є дійсним 
;завантажувальним сектором, і тільки після цього віддає управління коду, розташованому в цьому секторі.

;реєстри в 16 бітній архітектурі
;ax (accumulator) - аккумулятор, використовується для арифметичних операцій та зберігання даних.
;bx (base) - базовий регістр, використовується для адресації та зміщення.
;cx (counter) - регістр лічильника, використовується для лічильних циклів та ітерацій.
;dx (data) - регістр даних, використовується для операцій вводу-виводу та арифметики.
;si (source index) - індекс джерела, використовується для адресації даних у джерелі.
;di (destination index) - індекс призначення, використовується для адресації даних у місці призначення.
;bp (base pointer) - вказівник бази, використовується для адресації стекових даних.
;sp (stack pointer) - вказівник стеку, використовується для взаємодії зі стеком.

;команди в 16 бітній архітектурі, які використовували в цьому файлі
;xor - логічне "виключаюче або"
;mov - пересилання даних між регістрами та пам'яттю
;call - викли функції
;int - виклик преривання програмного забезпечення
;cmp - порівняння
;je - перехід до виконнання, якщо порівняння має рівні значення
;lodsb - завантаження байту з джерела в al
;jmp - безумовний перехід в інше місце програми
;ret - зупинка виконання функції та повернення в ту частину програми, де була ця функція оголошена
;dec - зменшення значення на 1
