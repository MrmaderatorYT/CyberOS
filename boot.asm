; Updated by CyberCraft Studio on 08.26.2024
[bits 16]            ; Указує, що код 16-бітний (реальний режим процесора)
[org 0x7c00]         ; Встановлює початкову адресу для завантаження коду в пам'ять

start:
    xor ax, ax       ; Очищення регістра AX (встановлення в 0)
    mov ds, ax       ; Встановлення сегментного регістра DS на нульову адресу (0x0000)
    mov es, ax       ; Встановлення сегментного регістра ES на нульову адресу (0x0000)

    ; Виведення вітального повідомлення
    mov si, hello    ; Завантажує адресу рядка з привітанням в регістр SI
    call print_string ; Виклик функції для виведення рядка

    ; Очистка буфера
    mov byte [input_index], 0 ; Скидання індексу буфера команд (починаємо з 0)

input_loop:
    ; Очікування введення символа
    mov ah, 0        ; Встановлення функції BIOS для отримання символу з клавіатури (int 16h)
    int 16h          ; Виклик переривання для зчитування символу
    mov bl, al       ; Збереження введеного символу в регістр BL

    ; Перевірка на Enter
    cmp al, 0x0D     ; Перевірка, чи введено Enter (0x0D)
    je process_command ; Якщо так, перейти до обробки команди

    ; Вивід символа
    call print_char  ; Виклик функції для виведення символу на екран

    ; Збереження символа в буфер
    movzx si, byte [input_index] ; Завантаження індексу буфера команд в регістр SI
    mov [command_buffer + si], bl ; Збереження символу в буфер команд
    inc byte [input_index] ; Збільшення індексу буфера на 1

    ; Повернення до циклу введення
    jmp input_loop  ; Повернення до циклу очікування вводу

process_command:
    ; Завершення строки нульовим байтом
    movzx si, byte [input_index] ; Завантаження індексу буфера команд в регістр SI
    mov byte [command_buffer + si], 0 ; Завершення рядка команд нульовим байтом

    ; Перевірка на команду "version"
    mov si, command_buffer  ; Завантаження адреси буфера команд в регістр SI
    mov di, version_cmd     ; Завантаження адреси команди "version" в регістр DI
    call compare_strings    ; Виклик функції для порівняння рядків
    cmp al, 1               ; Перевірка, чи рядки рівні (якщо так, al = 1)
    je debug_version        ; Якщо команда "version", перейти до відлагодження версії

    ; Перевірка на команду "reboot"
    mov si, command_buffer  ; Завантаження адреси буфера команд в регістр SI
    mov di, reboot_cmd      ; Завантаження адреси команди "reboot" в регістр DI
    call compare_strings    ; Виклик функції для порівняння рядків
    cmp al, 1               ; Перевірка, чи рядки рівні (якщо так, al = 1)
    je debug_reboot         ; Якщо команда "reboot", перейти до відлагодження перезавантаження

    ; Невідома команда
    mov si, unknown_command_msg ; Завантаження адреси рядка з повідомленням про невідому команду в регістр SI
    call print_string        ; Виклик функції для виведення повідомлення

    ; Скидання буфера команди та повернення до циклу введення
    jmp reset_input         ; Перехід до скидання буфера команд і повернення до циклу вводу

debug_version:
    ; Debug - якщо команда version опізнана
    mov si, debug_version_msg ; Завантаження адреси рядка з повідомленням про розпізнавання команди "version"
    call print_string         ; Виклик функції для виведення повідомлення
    jmp print_version         ; Перехід до функції виведення версії

debug_reboot:
    ; Отладка - команда reboot распознана
    mov si, debug_reboot_msg  ; Завантаження адреси рядка з повідомленням про розпізнавання команди "reboot"
    call print_string         ; Виклик функції для виведення повідомлення
    jmp reboot_system         ; Перехід до функції перезавантаження системи

print_version:
    mov si, version_info      ; Завантаження адреси рядка з інформацією про версію в регістр SI
    call print_string         ; Виклик функції для виведення рядка
    jmp reset_input           ; Перехід до скидання буфера команд і повернення до циклу вводу

reboot_system:
    mov al, 0xFE              ; Встановлення команди перезавантаження (0xFE) в регістр AL
    out 0x64, al              ; Відправка команди до порту 0x64 (контролер клавіатури 8042)
    hlt                       ; Зупинка процесора (halt)

reset_input:
    ; Скидання буфера команди та повернення до циклу введення
    mov byte [input_index], 0 ; Скидання індексу буфера команд
    call new_line             ; Виклик функції для переходу на новий рядок
    jmp input_loop            ; Повернення до циклу вводу

compare_strings:
    ; Порівняння двух ряядків
    push si                   ; Збереження поточного значення регістра SI на стек
    push di                   ; Збереження поточного значення регістра DI на стек
.compare_loop:
    lodsb                     ; Завантаження символу з пам'яті (адреса в SI) в AL і збільшення SI
    scasb                     ; Порівняння символу в AL з символом у пам'яті (адреса в DI) і збільшення DI
    jne not_equal             ; Якщо символи не рівні, перейти до not_equal
    cmp al, 0                 ; Перевірка, чи досягнуто кінця рядка (нулевий байт)
    jne .compare_loop         ; Якщо ні, повернутися до порівняння наступних символів
    mov al, 1                 ; Якщо рядки рівні, встановити AL в 1
    pop di                    ; Відновлення значення DI зі стека
    pop si                    ; Відновлення значення SI зі стека
    ret                       ; Повернення з функції
not_equal:
    mov al, 0                 ; Якщо рядки не рівні, встановити AL в 0
    pop di                    ; Відновлення значення DI зі стека
    pop si                    ; Відновлення значення SI зі стека
    ret                       ; Повернення з функції

print_string:
    mov ah, 0x0E              ; Встановлення функції для друку символу на екран (BIOS int 10h, функція 0Eh)
print_loop:
    lodsb                     ; Завантаження символу з пам'яті (адреса в SI) в AL і збільшення SI
    cmp al, 0                 ; Перевірка, чи досягнуто кінця рядка (нулевий байт)
    je print_done             ; Якщо досягнуто кінця, перейти до завершення друку
    int 0x10                  ; Виклик BIOS для друку символу
    jmp print_loop            ; Повернення до друку наступного символу
print_done:
    ret                       ; Повернення з функції

print_char:
    mov ah, 0x0E              ; Встановлення функції для друку символу на екран (BIOS int 10h, функція 0Eh)
    mov al, bl                ; Завантаження символу з BL в AL для друку
    int 0x10                  ; Виклик BIOS для друку символу
    ret                       ; Повернення з функції

new_line:
    mov ah, 0x0E              ; Встановлення функції для друку символу на екран (BIOS int 10h, функція 0Eh)
    mov al, 0x0D              ; Завантаження символу переводу каретки (Carriage Return) в AL
    int 0x10                  ; Виклик BIOS для друку символу
    mov al, 0x0A              ; Завантаження символу нового рядка (Line Feed) в AL
    int 0x10                  ; Виклик BIOS для друку символу
    ret                       ; Повернення з функції

hello db 'CyberOS terminal edition version 0.1',0x0A, 0x0D, 0 ; Привітальне повідомлення з завершенням нульовим байтом
version_info db 'Version: 0.1', 0x0A, 0x0D, 0                ; Інформація про версію з завершенням нульовим байтом
unknown_command_msg db 'Unknown command', 0x0A, 0x0D, 0      ; Повідомлення про невідому команду з завершенням нульовим байтом

version_cmd db 'version', 0  ; Рядок з командою "version", завершений нульовим байтом
reboot_cmd db 'reboot', 0    ; Рядок з командою "reboot", завершений нульовим байтом

debug_version_msg db 'Version command recognized', 0x0A, 0x0D, 0 ; Повідомлення про розпізнання команди "version"
debug_reboot_msg db 'Reboot command recognized', 0x0A, 0x0D, 0   ; Повідомлення про розпізнання команди "reboot"

command_buffer times 20 db 0 ; Буфер для введеної команди (20 байтів)
input_index db 0             ; Індекс для буфера команд (початкове значення 0)

times 510 - ($-$$) db 0x00   ; Заповнення коду нулями до 510 байтів (до завантажувального сектора)
dw 0xAA55                    ; Завантажувальний сигнатурний байт (завершення завантажувального сектора)

;реєстри в 16 бітній архітектурі
;ax (accumulator) - аккумулятор, використовується для арифметичних операцій та зберігання даних.
;bx (base) - базовий регістр, використовується для адресації та зміщення.
;cx (counter) - регістр лічильника, використовується для лічильних циклів та ітерацій.
;dx (data) - регістр даних, використовується для операцій вводу-виводу та арифметики.
;si (source index) - індекс джерела, використовується для адресації даних у джерелі.
;di (destination index) - індекс призначення, використовується для адресації даних у місці призначення.
;bp (base pointer) - вказівник бази, використовується для адресації стекових даних.
;sp (stack pointer) - вказівник стеку, використовується для взаємодії зі стеком.

;команди в 16 бітній архітектурі, які використовували в цьому файлі
;xor - логічне "виключаюче або"
;mov - пересилання даних між регістрами та пам'яттю
;movzx (move with zero-extended) переносить дані з регістру чи пам'яті в інший регістр/пам'ять. Розширюючи їх до більшого розміру.
;call - викли функції
;int - виклик преривання програмного забезпечення
;cmp - порівняння
;je - перехід до виконнання, якщо порівняння має рівні значення
;lodsb - завантаження байту з джерела в al
;scasb - scan string byte - порівнює байт в пам'яті вказаної в di з байтом регістра al
;jmp - безумовний перехід в інше місце програми
;ret - зупинка виконання функції та повернення в ту частину програми, де була ця функція оголошена
;dec - зменшення значення на 1
;push - заносить знаення у стек з регістру
;pop - витягує значення зі стеку і заносить у регістр.
;inc - збільшує значення на 1
